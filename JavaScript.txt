FROM EP-1 
1. JavaScript is synchronous and single threaded language(which means it will executed of commands one by one after one get executed)



FROM EP-2
2. it divide in two parts memory and code first part is called memory creation phase and second part is called code execution phase first phase will store only define and store function,classes of code and in second phase it will add values of function that we have written in code

3. once a program execution is complete whole global context(content)(background running activity for JavaScript code) will be deleted 

4. it have call stake in that stake at the bottom there is global execution context(gec)rely and than it starts execution from e1 part means first part of code get execution in upper phase of gec and then it removes same thing will repeat until all EC get executed after than GEC get remove from stack or delete from stack will happen and stack is empty after than

5. call stake have different names like Execution Context Stack,Program Stack,Control Stack,Runtime Stack and Machine Stack



FROM EP-3
6. In hoisting concept you can call function before initialize them in code and later on you can create function but this method can store function and internal code with values but cant be help with single variable because it can declare variable but it cannot take any initialize values in hoisting

7. In arrow function it is also act as variable when it comes in hoisting(means accessing before initialization) values will be undefined and throw an error



FROM EP-4
-> Function Work & Variable Environment In JavaScript
8. "declaring variable with any name and put it for output line using console and than adding two function calling that hasn't been made after that make those function with same variable name"   whole function calling will be same as defined in output means if there is function with variable it will start executing once it get executed it will remove and then another function comes it will repeat same story and then you have last variable it will get execute because define in last but in hoisting method (all of execution goes one by one and gets done it will remove from backend function with same variable name doesn't get any different effect of execution because all will be inside function and it have those limitations also work the same outcome without hoisting)  



FROM EP-5
9. This keyword also known as global keyword work as global and even if we don't define as global it will take as global.

10. If we don't define any code in tab it still runs it's engine and check for it if there is any code is available or not and do its regular functionality



FROM EP-6
-> undefined & notDefined in JavaScript
11.JavaScript is also known as weakly type language & loosely type of language it means once you stored variable a string it still allow to take other data types on later or at that time in code but if it is strict type language not allowed once you allow data type of that specific variable

12. undefined variables will be take default when you initialize them whether in case of  not defined is that you haven't initialize or created that variable



FROM EP-7
-> Scope,Scope Chain & Lexical Environment
13. Scope is current context of code, which determines the accessibility of variables to JavaScript

14. Lexical environment has access variable from a parent and use when it comes to terms of execution

15. Scope chain will check code on three phases first it start it with local level and then its parent level if it cant find it then it will check on global level all these process to find variable of code that we have defined/used called scope chain



FROM EP-8
-> let & const(temporal dead zone) in JavaScript
16. Temporal dead zone is between time of hoisting and outcome(output) value is being printed or not always applicable in terms of "let & const" for both of them

17. Window & This can access variable of var because they are available on globally on code and print the value whether in case of this it can't be accessed because let have blocked and not available global so it will print error

18. It cant access value before initialize them after initialize them we can access those value(rule is applicable for const & let)



FROM EP-9
-> Block Scope & Shadowing
19. block also known as compound statement It uses to combine multiple statement code into one group ({}) is called as block scope/block

20. Shadowing a variable declared in a certain scope (has the same name as a variable in an outer scope and illegal shadowing had few limitations and rules to apply



FROM EP-10
-> Closures in JavaScript
21. closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment) even if it has no physical keywords or code to access it is still important part of javascript code

22. closure can be used in module design pattern,currying,functions like once,memoize,maintaining state in async world,setTimeouts,Iterators,etc...



FROM EP-11
-> setTimeout & closures
22. setTimeout sets a timer which executes a function or specified piece of code once the timer expires



FROM EP-13
-> First class function & anonymous function
23. Function statement are regular function with normal structure

24. Function expression can store function inside created new variable

25. Anonymous function are function without name and can not allow a function without name it will throw error

26. difference between function expression and named function expression is it have variable and function name both allowed in code but it wont allow at calling time only variable can be called function name will throw error

27. parameters are passed in function whether actual value or arguments are passed later in that function for output(parameter & argument)

28. we can pass function function inside a function it can be made an use an output using different method(of first class function) they are also known as first class citizen in javascript 



FROM EP-14
29. callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action

30. we can use callback function & Event listener in timeout method with help of closure(lexical scope) & regular function that make counts for each time track number records we have clicked created button and targeted with id

31.removeEventListener when we don't need to use in code because event listener takes big amount of space unnecessarily that make code heavy and slow in execution suppose we make page with thousands of events attached even if we don't gonna use less or no use it will make execution slow of that page so if we don't need events when they have not much use we can remove 



FROM EP-12
32. Data Encapsulation(Data Hiding)cant access internal function of some parent directly it will throw error of reference error  But we can access them through calling main function inside a variable and it will increase count each time we call that variable

33. Constructor is a special function that creates and initializes an object instance of a class In JavaScript, a constructor gets called when an object is created using the new keyword



FROM EP-15
34. console,DOM API(ex: Document.)s,setTimeout,fetch() are actually not an javascript function or code but they are part of WEB APIs that service provided by browser

35. Event loop keeps check between all events that are performed in call stack,callback queue & microtask queue and keep giving values and checking them whether all task is performed/empty/adding/deleting/etc... or not

36. Call stack is mainly responsible to perform all given task but there are more two types of task we can perform with two different types of queues

37. callback queue used to store callback timer until time reaches out and it will run when global function are run in call stack snd completed and there is space is empty for callback to call his timers event loop start to assign them in call stack till then callback queue saves and keep records of callbacks(callback queue is also known as task queue in javascript)

38. there one more bigger place in hierarchy microtask queue they have higher priority than callback queue it uses to store callback functions they will run when global function are run in call stack snd completed and there is space is empty for callback functions it will assign in call stack and start executing with help of event loop to assign them in call stack if there are both available callback timer and callback function they will execute callback function first and then turn goes for callback timers

39. Starvation of callback queue will happen when they are too many function of microtask queue is running because they are prioritized more even there are only one callback queue have left it wont let run by event loop so if there are too many function in microtask queue callback queue dont get chance to run its functions